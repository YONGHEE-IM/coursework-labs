## 문제 1
from PIL import Image
import numpy as np

def process_image(image_path, L, characters):
    # 1. 이미지 읽기 및 흑백 변환
    img = Image.open(image_path).convert('L')

    # 2. 양자화
    img_array = np.array(img)
    quantized = (img_array // (256 // L)).astype(int)

    # 3. 문자 치환
    # Ensure characters length matches L
    if len(characters) < L :
        raise ValueError("Number of characters must match or exceed the quantization levels (L).")
    
    ascii_art = '\n'.join(
        ''.join(characters[value] for value in row) for row in quantized
    )

    # 4. 결과 출려
    print(ascii_art)

# 예제 사용
image_path = 'example_image.jpg'  # 이미지 경로
L = 5  # 양자화 레벨
characters = ['@', '#', '%', '.', ' '] # 치환할 문자 리스트
process_image(image_path, L, characters)

## 문제 2
def restore_image(image_path, piece_order):
    # 이미지 열기
    img = Image.open(image_path)
    width, height = img.size

    # 조각 크기 계산 
    piece_width, piece_height = width // 2, height // 2

    # 조각 분리
    pieces = [
        img.crop((0, 0, piece_width, piece_height)),  # 0번 조각
        img.crop((piece_width, 0, width, piece_height)),  # 1번 조각
        img.crop((0, piece_height, piece_width, height)),  # 2번 조각
        img.crop((piece_width, piece_height, width, height)),  # 3번 조각
    ]
    # 조각 재배치
      img.crop((0, 0, piece_width, piece_height)),  # 0번 조각
        img.crop((piece_width, 0, width, piece_height)),  # 1번 조각
        img.crop((0, piece_height, piece_width, height)),  # 2번 조각
        img.crop((piece_width, piece_height, width, height)),  # 3번 조각
    
    for i, piece_idx in enumerate(piece_order):
       new_img.paste(pieces[piece_idx], positions[i])

    return new_img

# 예제 실행
piece_order = [3, 2, 1, 0]  # 주어진 순서
restored_image = restore_image('/mnt/data/image.png', piece_order)

# 결과 저장 및 확인
restored_image.save('/mnt/data/restored_image.png')
restored_image.show()

## 문제 3
import cv2
import numpy as np

def draw_histogram(image_path, output_path):
   # 1. 이미지 로드 및 그레이스케일 변환
   image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

   # 2. 이미지의 전체 화소 수 계산
   total_pixels = image.shape[0] * image.shape[1]

   # 3. 히스토그램 계산 (명도별 화소 개수 세기)
    histogram = cv2.calcHist([image], [0], None, [256], [0, 256]).flatten()

    # 4. 히스토그램 데이터 정규화 (높이를 전체 이미지의 비율로 표현)
    max_pixel_count = max(histogram)
    normalized_histogram = (histogram / max_pixel_count * 255).astype(int)

    # 5. 흰색 바탕 이미지 생성
    graph_height = 256  # 그래프 높이
    graph_width = 256  # 그래프 폭 (명도 개수)
    white_image = np.ones((graph_height, graph_width), dtype=np.uint8) * 255

    # 6. 히스토그램 그래프 그리기
    for x, pixel_count in enumerate(normalized_histogram):
        # y 좌표 변환 (그래프는 아래에서 위로 그려야 함)
        y_start = graph_height - 1
        y_end = graph_height - 1 - pixel_count
        cv2.line(white_image, (x, y_start), (x, y_end), color=0, thickness=1)

    # 7. 결과 저장
    cv2.imwrite(output_path, white_image)
    print(f"히스토그램 이미지가 저장되었습니다: {output_path}")

# 실행 예제
image_path = "/mnt/data/image.png"  # 입력 이미지 경로
output_path = "/mnt/data/histogram.png"  # 저장할 히스토그램 이미지 경로
draw_histogram(image_path, output_path)

## 문제 4
import cv2

def binary_threshold(image_path, threshold, output_path):
    # 1. 이미지 로드 및 그레이스케일 변환
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # 2. 이진화 처리 (임곗값 기준)
    _, binary_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)

    # 3. 결과 저장
    cv2.imwrite(output_path, binary_image)
    print(f"이진화된 이미지가 저장되었습니다: {output_path}")

# 실행 예제
image_path = "/mnt/data/image.png"  # 입력 이미지 경로
output_path = "/mnt/data/binary_image.png"  # 저장할 이진화 이미지 경로
threshold = 127  # 임곗값
binary_threshold(image_path, threshold, output_path)


## 문제 5
def extract_color_range(image_path, thresholds, output_path):
    """
    특정 색상 영역을 추출하는 함수.
    
    :param image_path: 입력 컬러 이미지 경로
    :param thresholds: R, G, B 채널별 임곗값 범위 (리스트: [R_min, R_max, G_min, G_max, B_min, B_max])
    :param output_path: 결과 이미지를 저장할 경로
    """
    # 1. 이미지 로드
    image = cv2.imread(image_path)

    # 2. 임곗값 분리 (R, G, B 채널별 범위)
    R_min, R_max, G_min, G_max, B_min, B_max = thresholds

    # 3. 채널별 마스크 생성
    R_mask = cv2.inRange(image[:, :, 2], R_min, R_max)  # R 채널
    G_mask = cv2.inRange(image[:, :, 1], G_min, G_max)  # G 채널
    B_mask = cv2.inRange(image[:, :, 0], B_min, B_max)  # B 채널

    # 4. 마스크 합성 (모든 조건이 만족하는 영역)
    ombined_mask = cv2.bitwise_and(cv2.bitwise_and(R_mask, G_mask), B_mask)

    # 5. 추출된 영역만 남기기
    result = cv2.bitwise_and(image, image, mask=combined_mask)

    # 6. 결과 저장
    cv2.imwrite(output_path, result)
    print(f"특정 색상 영역 추출 결과가 저장되었습니다: {output_path}")

# 실행 예제
image_path = "/mnt/data/image.png"  # 입력 이미지 경로
output_path = "/mnt/data/extracted_color.png"  # 저장할 이미지 경로
thresholds = [50, 255, 10, 200, 200, 255]  # R, G, B 채널별 임곗값 범위
extract_color_range(image_path, thresholds, output_path)

## 문제 6
def prewitt(image_path, output_path):
   """
    프리윗 필터를 적용하여 에지 검출 결과를 반환하는 함수.
    
    :param image_path: 입력 영상 경로
    :param output_path: 결과 이미지를 저장할 경로
    :return: 수직/수평 프리윗 필터 합산 결과 이미지
    """
   # 1. 이미지 로드 및 그레이스케일 변환
   image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

   # 2. 수직 및 수평 프리윗 필터 정의
   prewitt_vertical = np.array([[1, 0, -1],
                                 [1, 0, -1],
                                 [1, 0, -1]], dtype=np.float32)
    
    prewitt_horizontal = np.array([[1, 1, 1],
                                   [0, 0, 0],
                                   [-1, -1, -1]], dtype=np.float32)
   
   # 3. 프리윗 필터 적용 (수직, 수평)
   dst_vertical_edge = cv2.filter2D(image, ddepth=-1, kernel=prewitt_vertical)
   dst_horizontal_edge = cv2.filter2D(image, ddepth=-1, kernel=prewitt_horizontal)

   # 4. 수직과 수평 필터링 결과 합산
   combined_edge = cv2.add(dst_vertical_edge, dst_horizontal_edge)

   # 5. 결과 저장
   cv2.imwrite(output_path, combined_edge)
   print(f"프리윗 필터 결과가 저장되었습니다: {output_path}")

   return combined_edge

# 실행 예제
image_path = "/mnt/data/image.png"  # 입력 영상 경로
output_path = "/mnt/data/prewitt_edge.png"  # 저장할 결과 경로
result = prewitt(image_path, output_path
   
## 문제 7
import numpy as np

def convolution2D(img, kernel):
    # 이미지 크기와 커널 크기
    img_height, img_width = img.shape
    kernel_height, kernel_width = kernel.shape
    
    # 출력 이미지 크기 계산 (패딩을 하지 않음)
    output_height = img_height - kernel_height + 1
    output_width = img_width - kernel_width + 1
    
    # 출력 이미지 초기화
    dst = np.zeros((output_height, output_width))
    
    # 이미지의 각 위치에 대해 커널을 적용
    for i in range(output_height):
        for j in range(output_width):
            # 해당 위치의 부분 이미지 (커널 크기와 동일한 영역)
            region = img[i:i+kernel_height, j:j+kernel_width]
            # 커널과 해당 부분 이미지의 요소별 곱의 합
            dst[i, j] = np.sum(region * kernel)
    
    return dst
